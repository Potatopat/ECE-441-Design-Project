00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.29
Created On: 11/29/2017 1:22:51 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Patrick Bartman's Design Project
00000000                             3  * Written by :  Patrick Bartman
00000000                             4  * Date       :  11/30/2017
00000000                             5  * Description:  
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  4280                      12      CLR.L   D0
00001002  4281                      13      CLR.L   D1
00001004                            14      
00001004                            15  * see http://www.easy68k.com/QuickStart/Hello%20World%20Program%203.txt
00001004                            16  
00001004                            17  LOOP:
00001004  43F9 00001046             18      LEA     MONITOR,A1  ; gives command prompt
0000100A  103C 000E                 19      MOVE.B  #14,D0      ; stores result in D0
0000100E  4E4F                      20      TRAP    #15
00001010                            21      
00001010                            22  INPUT:
00001010  43F9 00001053             23      LEA     BUFFER,A1   ; TODO: need to increment buffer if trying to store, or clear if not
00001016  103C 0002                 24      MOVE.B  #2,D0       ; trap task 2 does the following:
0000101A  4E4F                      25      TRAP    #15         ; read a string from the keyboard into A1 of length stored at D1.W
0000101C  2242                      26      MOVEA.L D2,A1
0000101E  B27C 0000                 27      CMP.W   #0,D1       ; compares D1 to the number 0 to see if not empty
00001022  6700 0018                 28      BEQ     DONE        ; branch DONE if they are equal
00001026                            29      
00001026                            30  * do code to determine what to do next here
00001026                            31  
00001026                            32  * PSUEDOCODE:   
00001026                            33  * check if text in ?buffer? is equal to possible commands one by one
00001026                            34  * see http://freesource-codes.blogspot.com/2011/11/string-comparision-in-assembly-language.html
00001026                            35  * will be super long, but entirely copy-paste
00001026                            36      
00001026                            37      
00001026                            38      
00001026                            39      
00001026                            40  RETURN:
00001026                            41      ;MOVE.B  #14,D0      ; go back to monitor
00001026                            42      ;TRAP    #15
00001026  60DC                      43      BRA     LOOP
00001028                            44  
00001028                            45  HELP:
00001028  43F9 000010A3             46      LEA     HELPTEXT,A1 ; load helptext into a1
0000102E  103C 000E                 47      MOVE.B  #14,D0      ; display text
00001032  4E4F                      48      TRAP    #15
00001034  60F0                      49      BRA     RETURN
00001036                            50      
00001036                            51  GO:
00001036                            52      * TODO: load branching address into A7 during string parsing
00001036                            53      * TODO: make sure it is valid memory address via BGE, BLE, etc.
00001036                            54      
00001036                            55      * GO
00001036                            56      * LEA     INPUT, A5
00001036                            57      * ADD     #$03, A5
00001036                            58      * JSR     GET_ARG
00001036                            59      * LEA     OUT_BUFF, A1
00001036                            60      * MOVE.L  D7, A1
00001036                            61      * JMP     (A1)
00001036                            62      
00001036  4E97                      63      JSR (A7)            ; branch to location to run that program
00001038                            64  
00001038                            65  EXIT:
00001038  6000 0002                 66      BRA     DONE
0000103C                            67  
0000103C                            68  DONE:
0000103C  103C 0009                 69      MOVE.B  #9,D0
00001040  4E4F                      70      TRAP    #15         ; halt simulator
00001042                            71      
00001042                            72      
00001042                            73  
00001042  FFFF FFFF                 74      SIMHALT             ; halt simulator
00001046                            75  
00001046                            76  * Put variables and constants here
00001046                            77  
00001046= 4D 4F 4E 49 54 4F ...     78  MONITOR     DC.B    'MONITOR441> ',0                        ; command prompt input message
00001053                            79  BUFFER      DS.B    80                                      ; input string storage          ; 103F      ; TODO: find out if 80 is length of buffer, or what else it could be
000010A3  =0000000D                 80  CR          EQU     $0D                                     ; ascii code for carriage return
000010A3  =0000000A                 81  LF          EQU     $0A                                     ; ascii code for line feed
000010A3= 4D 44 53 50 09 4D ...     82  HELPTEXT    DC.B    'MDSP   Memory Display',CR,LF           ; ascii string with new line
000010B8= 53 4F 52 54 57 09 ...     83              DC.B    'SORTW  Sort',CR,LF
000010C4= 4D 4D 09 09 4D 65 ...     84              DC.B    'MM     Memory Modify',CR,LF
000010D7= 4D 53 09 09 4D 65 ...     85              DC.B    'MS     Memory Set',CR,LF
000010E7= 42 46 09 09 42 6C ...     86              DC.B    'BF     Block Fill',CR,LF
000010F7= 42 4D 4F 56 09 42 ...     87              DC.B    'BMOV   Block Move',CR,LF
00001108= 42 53 43 48 09 42 ...     88              DC.B    'BSCH   Block Test',CR,LF
00001119= 47 4F 09 09 45 78 ...     89              DC.B    'GO     Execute Program',CR,LF
0000112E= 44 46 09 09 44 69 ...     90              DC.B    'DF     Display Formatted Registers',CR,LF
0000114F= 45 58 49 54 09 45 ...     91              DC.B    'EXIT   Exit Monitor Program',CR,LF
0000116A= 00                        92              DC.B    '',0
0000116B= 48 45 4C 50 00            93  HELP_COMP   DC.B    'HELP',0
00001170= 45 58 49 54 00            94  EXIT_COMP   DC.B    'EXIT',0
00001175= 3F 20 00                  95  Q_MARK      DC.B    '? ',0
00001178                            96  
00001178                            97  
00001178                            98      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BUFFER              1053
CR                  D
DONE                103C
EXIT                1038
EXIT_COMP           1170
GO                  1036
HELP                1028
HELPTEXT            10A3
HELP_COMP           116B
INPUT               1010
LF                  A
LOOP                1004
MONITOR             1046
Q_MARK              1175
RETURN              1026
START               1000
